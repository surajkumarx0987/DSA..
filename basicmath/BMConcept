#Extraction of digits

       N = 5678
           5678 % 10 = 8
           567 % 10 = 7
           56 % 10 = 6
           5 % 10 = 0

           while (N>0){
              length = N % 10
              N = N % 10
              }
   Note: If a problem is divisible then its time comlexity is logrithmic

   # for Reverse of a number -> reverseNumber = (reverseNumber * 10) + lastdigit

   # Palindrome number  -> 121 reverse is also 121 , 1331 , 7  etc.
              reverse is exactly same as original

   # Armstrong Number ->also called a Narcissistic number -> N = 371 = 3^3 + 7^3 + 1^3 = 371
            153 = 1³ + 5³ + 3³ = 153 ✅ Armstrong

            9474 = 9⁴ + 4⁴ + 7⁴ + 4⁴ = 9474 ✅ Armstrong

            123 = 1³ + 2³ + 3³ = 36 ❌ Not Armstrong

   #Print all divisor of a number
      example -> 36 = 1,2,3,4,6,9,12,18,36
        divisor -> 1 to N
        for(i=1; i<=N; i++){
           if(N%i==0){
           print -> i
           }
        }

   #check for prime number
     exactly two factors 1 & itself
     #not good as compare to time comlexity
     if(n <= 1 ){
       return false;
     }
     for(i=2; i<n; i++){
     if(n%i==0){
     return false;
     }
     return true;

     ##check -> PrimeNumber.java class

   # GCD(greatest common divisor) | HCF(highest common factor)

      N1=9 ->  1 , 3 , 9
      N2=12 -> 1 , 2 , 3 , 4 , 6 , 12
        common = 1 , 3

       #Concept             TC ->  O(min(N1,N2))
       for(i=1; i<=Min(N1,N2); i++){
         if(N1%i==0 && N2%i==0){
           gcd = i;
         }
       }

       --> enhanced
       for(i=Min(N1,N2); i>=1; i--){
         if(N1%i==0 && N2%i==0){
           gcd = i;
           break;
         }
       }
       # Euclidean algorithm
          gcd(a,b) = gcd(a%b,b)    a>b
           greater % smaller -> one of them is 0 and then other is answer
           TC -> O(log$(min(a,b)))
